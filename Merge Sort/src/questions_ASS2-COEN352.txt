{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf600
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww18500\viewh8700\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Questions\
\
2. \
The main performance difference between the two sorts can be explained on the runs which the two algorithms use. The regular MergeSort will just take runs of one, then 2 and 4 etc regardless of whether the runs are already in order or not whereas the StructuredMergeSort takes advantage of that. Therefore if there are significant amount of sorted runs, ascending or descending, the second algorithm is more efficient.\
\
3.\
As StructuredMergeSort takes advantage of ascending or descending runs, the best case would be when the array has lots of long runs. It speeds up the process of partitioning the array since it does not to separate each into runs of 1 and 2 etc\'85 However, if there are no runs to take advantage of, the regular MergeSort is more effective since it will not try to look for runs.\
\
4.\
The JumpList provided a means to store the runs (mostly the indices of runs) despite adding an extra space complexity of n. The implementations made sure that no extra buffer was required when dividing and merging runs. It helped in keeping track of the runs.}